<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Object Placement - FPV Mode</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    
    <style>
        :root {
            --glass-bg: rgba(20, 20, 20, 0.85);
            --glass-border: 1px solid rgba(255, 255, 255, 0.15);
            --accent: #2ecc71;
            --active-item: rgba(46, 204, 113, 0.3);
        }

        body {
            margin: 0; overflow: hidden; background-color: #111;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            -webkit-user-select: none; user-select: none;
        }

        /* START SCREEN */
        #start-screen {
            display: block; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30,30,30,0.9); padding: 30px; border-radius: 20px;
            text-align: center; color: white; border: var(--glass-border);
            pointer-events: auto; z-index: 200; width: 80%; max-width: 300px;
        }

        /* AR DOM OVERLAY ROOT */
        #ar-root {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            /* Ar-root should not block events to the scene by default, interactive children will override */
            pointer-events: none; 
            z-index: 100;
        }

        /* STANDARD UI CONTAINER */
        #standard-ui {
            display: flex; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            flex-direction: column; justify-content: space-between; 
            pointer-events: none; /* Controlled by JS when active */
        }

        .interactive { pointer-events: auto !important; }

        #btn-start {
            margin-top: 20px; padding: 12px 30px; background: var(--accent);
            border: none; border-radius: 50px; color: white; font-weight: bold;
        }
        #btn-start:disabled { background: #555; color: #888; }

        /* HUD Styles */
        .icon-btn {
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(50,50,50,0.8); border: var(--glass-border);
            color: white; font-size: 18px; display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(10px); margin-left: 10px;
        }
        .red { color: #ff6b6b; background: rgba(80,0,0,0.6); }

        #hud-top { padding: 20px; display: flex; justify-content: flex-end; pointer-events: none; }
        #hud-bottom { padding: 20px; padding-bottom: 40px; display: flex; flex-direction: column; align-items: center; gap: 10px; pointer-events: none; }

        #toast {
            background: rgba(0,0,0,0.6); color: white; padding: 8px 16px;
            border-radius: 20px; font-size: 13px; margin-bottom: 10px; text-align: center;
            backdrop-filter: blur(4px); transition: opacity 0.3s;
        }

        /* IDLE MENU */
        #idle-menu { display: flex; gap: 10px; pointer-events: none; transition: opacity 0.3s; }
        .btn-main {
            padding: 12px 24px; border-radius: 25px; border: var(--glass-border);
            background: var(--glass-bg); color: white; font-weight: 600;
            backdrop-filter: blur(12px); display: flex; align-items: center; gap: 8px;
        }
        .btn-main:active { transform: scale(0.95); }

        /* LIBRARY DRAWER */
        #library-drawer {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(20,20,20,0.95);
            border-top: var(--glass-border); border-radius: 20px 20px 0 0;
            padding: 20px; box-sizing: border-box;
            transform: translateY(110%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto !important;
            z-index: 150; display: flex; flex-direction: column; gap: 15px;
        }
        #library-drawer.open { transform: translateY(0); }
        .drawer-header { display: flex; justify-content: space-between; align-items: center; color: white; }
        .model-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; max-height: 200px; overflow-y: auto; }
        .model-card {
            background: rgba(255,255,255,0.05); border-radius: 12px; padding: 10px;
            text-align: center; cursor: pointer; border: 1px solid transparent; transition: all 0.2s;
        }
        .model-card.active { border-color: var(--accent); background: var(--active-item); }
        .model-icon { font-size: 24px; display: block; margin-bottom: 5px; }
        .model-name { font-size: 11px; color: #ccc; }

        /* Action Bar */
        #action-bar {
            display: none; flex-wrap: wrap; justify-content: center; gap: 10px;
            background: var(--glass-bg); padding: 12px 20px; border-radius: 24px;
            border: var(--glass-border); backdrop-filter: blur(12px); animation: slideUp 0.3s;
        }
        @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .pill-btn {
            padding: 10px 18px; border-radius: 20px; border: none; font-weight: 600; font-size: 13px;
            display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); color: white;
        }
        .btn-delete { background: rgba(231, 76, 60, 0.2); color: #ff8787; border: 1px solid rgba(231, 76, 60, 0.5); }
        .btn-fpv { background: rgba(46, 204, 113, 0.2); color: #2ecc71; border: 1px solid rgba(46, 204, 113, 0.5); }

        /* FPV UI */
        #fpv-ui { 
            display: none; 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            pointer-events: none; /* Controlled by JS when active */
            z-index: 150; 
        }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; pointer-events: auto; }
        #elevation-controls { position: absolute; bottom: 50px; right: 30px; display: flex; flex-direction: column; gap: 15px; pointer-events: auto; }
        .circle-big { width: 60px; height: 60px; font-size: 24px; background: rgba(255,255,255,0.1); }
        
        /* Loading Spinner */
        .loading {
            display: inline-block; width: 20px; height: 20px;
            border: 3px solid rgba(255,255,255,.3); border-radius: 50%;
            border-top-color: #fff; animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="start-screen">
        <h2>AR Object Placement</h2>
        <p id="status-text"><span class="loading"></span>Memeriksa WebXR...</p>
        <button id="btn-start" class="interactive" disabled>Mulai AR</button>
    </div>

    <!-- MAIN DOM OVERLAY ROOT -->
    <div id="ar-root">
        
        <!-- STANDARD UI LAYER -->
        <div id="standard-ui">
            <div id="hud-top">
                <button id="btn-reset" class="icon-btn interactive">â†º</button>
                <button id="btn-exit" class="icon-btn red interactive">âœ•</button>
            </div>
            
            <div style="flex:1"></div>
            
            <div id="hud-bottom">
                <div id="toast">Pilih model & ketuk lantai</div>
                
                <div id="idle-menu">
                    <button id="btn-library" class="btn-main interactive">ðŸ“‚ Library 3D</button>
                </div>

                <div id="action-bar" class="interactive">
                    <button id="btn-fpv" class="pill-btn btn-fpv">ðŸš¶ FPV</button>
                    <div style="width:1px; height:20px; background:rgba(255,255,255,0.2); margin: 0 5px;"></div>
                    <button id="btn-deselect" class="pill-btn">Batal</button>
                    <button id="btn-delete" class="pill-btn btn-delete">Hapus</button>
                </div>
            </div>

            <div id="library-drawer">
                <div class="drawer-header">
                    <h3>Pilih Model</h3>
                    <button id="btn-close-lib" class="icon-btn" style="width:30px; height:30px; font-size:14px;">âœ•</button>
                </div>
                <div class="model-list" id="model-list-container"></div>
            </div>
        </div>

        <!-- FPV UI LAYER -->
        <div id="fpv-ui">
            <div style="position:absolute; top:20px; left:20px;">
                <span style="background:var(--accent); color:white; padding:4px 10px; border-radius:10px; font-size:12px;">FPV MODE</span>
            </div>
            <div style="position:absolute; top:20px; right:20px; pointer-events:auto;">
                <button id="btn-exit-fpv" class="icon-btn interactive">âœ•</button>
            </div>
            <div id="joystick-zone"></div>
            <div id="elevation-controls">
                <button id="btn-up" class="icon-btn circle-big interactive">â–²</button>
                <button id="btn-down" class="icon-btn circle-big interactive">â–¼</button>
            </div>
        </div>

    </div>

    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        class ARObjectPlacement {
            constructor() {
                this.canvas = null;
                this.gl = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.session = null;
                this.referenceSpace = null;
                this.viewerSpace = null;
                this.hitTestSource = null;

                this.reticle = null;
                this.arObject = null;
                
                // Define available models with icons
                this.availableModels = [
                    { name: 'Tower House', url: 'tower_house_design.glb', icon: 'ðŸ ' },
                    { name: 'Kitchen', url: 'interior-fix2.glb', icon: 'ðŸ³' },
                    { name: 'Astronaut', url: 'Astronaut.glb', icon: 'ðŸ§‘â€ðŸš€' },
                    { name: '3 Bedroom House', url: '3 Bedroom house.glb', icon: 'ðŸ¡' },
                    // NEW OBJECTS: Pastikan Anda telah mengonversi file .obj ini ke format .glb
                    // dan letakkan di folder public/ agar dapat dimuat oleh GLTFLoader.
                    { name: 'Apartment Floor Plan', url: 'Apartment.glb', icon: 'ðŸ¢' },
                    { name: 'Room', url: 'Room.glb', icon: 'ðŸšª' },
                    { name : "Infinits Park", url: "Infinites.fbx", icon: "ðŸŒ³" }
                ];
                this.activeModelIndex = 0;

                this.placedObjects = [];
                this.selectedObject = null;
                this.objectIndex = 0;
                
                this.isUIInteraction = false;
                this.lastUIInteraction = 0;
                
                // Touch interaction state
                this.isDragging = false;
                this.touchStartX = 0;
                this.initialRotation = 0;
                this.startDist = 0;
                this.startScale = 1;

                // For object selection
                this.raycaster = new THREE.Raycaster();
                this.highlightBox = null;

                // FPV Mode
                this.fpvMode = false;
                this.fpvObject = null;
                this.fpvOriginalScale = new THREE.Vector3();
                this.fpvOriginalPosition = new THREE.Vector3();
                this.fpvOriginalRotation = new THREE.Euler();
                this.fpvTargetScale = 20; // Multiplier for 1:1 scale
                this.baseMovementSpeed = 0.1;
                this.movementSpeedMultiplier = 1;
                
                // FPV Collision Detection Properties
                // Increased playerRadius and playerHeight for more robust collision detection
                this.playerHeight = 1.8; // Approx user height in meters
                this.playerRadius = 0.5; // Approx user radius
                this.collisionRaycaster = new THREE.Raycaster();

                // FPV Control State
                this.moveVec = { x: 0, z: 0 }; // From joystick
                this.verticalSpeed = 0; // From buttons
                this.joystick = null;
                
                this.init();
            }
            
            async init() {
                this.initUI();
                await this.checkWebXRSupport();
                await this.loadModels(); // Loads the default model
                this.renderLibrary();
                this.createSelectionHighlight();
            }

            initUI() {
                // Main Menu
                document.getElementById('btn-start').onclick = () => this.startAR();
                document.getElementById('btn-exit').onclick = () => this.exitAR();
                document.getElementById('btn-reset').onclick = () => this.resetObjects();

                // Library Drawer
                document.getElementById('btn-library').onclick = (e) => {
                    e.stopPropagation();
                    this.isUIInteraction = true;
                    document.getElementById('library-drawer').classList.add('open');
                };
                document.getElementById('btn-close-lib').onclick = (e) => {
                    e.stopPropagation();
                    document.getElementById('library-drawer').classList.remove('open');
                };

                // Action Bar
                this.bindButton('btn-delete', () => this.deleteSelectedObject());
                this.bindButton('btn-deselect', () => this.deselectObject());
                this.bindButton('btn-fpv', () => this.enterFPVMode());
                document.getElementById('btn-exit-fpv').onclick = () => this.exitFPVMode();

                // FPV Elevation
                const setupHold = (id, val) => {
                    const btn = document.getElementById(id);
                    const start = (e) => { e.preventDefault(); this.verticalSpeed = val; };
                    const end = (e) => { e.preventDefault(); this.verticalSpeed = 0; };
                    btn.ontouchstart = start; btn.ontouchend = end;
                    btn.onmousedown = start; btn.onmouseup = end;
                };
                setupHold('btn-up', 0.05);
                setupHold('btn-down', -0.05);

                // Generic UI Interaction tracking
                const uiElements = document.querySelectorAll('.interactive, #library-drawer');
                uiElements.forEach(el => {
                    el.addEventListener('touchstart', () => { this.isUIInteraction = true; this.lastUIInteraction = Date.now(); });
                    el.addEventListener('touchend', () => { 
                        this.lastUIInteraction = Date.now(); 
                        setTimeout(() => { this.isUIInteraction = false; }, 200); 
                    });
                    el.addEventListener('click', (e) => { 
                        e.stopPropagation(); 
                        this.isUIInteraction = true; 
                        this.lastUIInteraction = Date.now(); 
                        setTimeout(() => { this.isUIInteraction = false; }, 200); 
                    });
                });

                // Touch gestures for scale/rotate
                window.addEventListener('touchstart', (e) => this.onTouchStart(e), {passive: false});
                window.addEventListener('touchmove', (e) => this.onTouchMove(e), {passive: false});
                window.addEventListener('touchend', () => this.onTouchEnd());
            }

            bindButton(id, callback) {
                const btn = document.getElementById(id);
                if(btn) btn.onclick = (e) => { e.stopPropagation(); callback(); };
            }

            renderLibrary() {
                const container = document.getElementById('model-list-container');
                container.innerHTML = '';
                this.availableModels.forEach((model, index) => {
                    const card = document.createElement('div');
                    card.className = `model-card ${index === this.activeModelIndex ? 'active' : ''}`;
                    card.innerHTML = `<span class="model-icon">${model.icon}</span><div class="model-name">${model.name}</div>`;
                    card.onclick = (e) => { 
                        e.stopPropagation(); 
                        this.selectModelFromLibrary(index); 
                    };
                    container.appendChild(card);
                });
            }

            async selectModelFromLibrary(index) {
                this.activeModelIndex = index;
                const model = this.availableModels[index];
                this.renderLibrary();
                
                this.showToast(`Memuat ${model.name}...`);
                
                try {
                    const loader = new THREE.GLTFLoader();
                    await this.loadSpecificModel(loader, model.url);
                    this.showToast(`${model.name} Siap!`);
                    document.getElementById('library-drawer').classList.remove('open');
                } catch (e) {
                    this.showToast('Gagal memuat model');
                }
            }

            showToast(msg) {
                const t = document.getElementById('toast');
                t.innerText = msg;
                t.style.opacity = 1;
                clearTimeout(this.toastTimer);
                this.toastTimer = setTimeout(() => t.style.opacity = 0, 3000);
            }

            createSelectionHighlight() {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const edges = new THREE.EdgesGeometry(geometry);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00, 
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.8
                });
                this.highlightBox = new THREE.LineSegments(edges, material);
                this.highlightBox.visible = false;
            }

            onTouchStart(e) {
                if (!this.selectedObject || this.fpvMode || this.isUIInteraction) return;
                this.isDragging = false; 
                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    this.startDist = Math.hypot(dx, dy);
                    this.startScale = this.selectedObject.scale.x;
                } else if (e.touches.length === 1) {
                    this.touchStartX = e.touches[0].pageX;
                    this.initialRotation = this.selectedObject.rotation.y;
                }
            }

            onTouchMove(e) {
                if (!this.selectedObject || this.fpvMode || this.isUIInteraction) return;
                
                if (e.touches.length === 2) {
                    e.preventDefault(); 
                    this.isDragging = true; 
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    const currDist = Math.hypot(dx, dy);
                    if (this.startDist > 0) {
                        const scaleFactor = currDist / this.startDist;
                        let newScale = this.startScale * scaleFactor;
                        newScale = Math.max(0.1, Math.min(newScale, 5.0));
                        this.selectedObject.scale.set(newScale, newScale, newScale);
                        this.updateHighlightBox();
                    }
                } else if (e.touches.length === 1) {
                    const dx = e.touches[0].pageX - this.touchStartX;
                    if (Math.abs(dx) > 10) {
                        this.isDragging = true; 
                        const sensitivity = 0.01;
                        this.selectedObject.rotation.y = this.initialRotation + (dx * sensitivity);
                        this.updateHighlightBox();
                    }
                }
            }
            
            onTouchEnd() { 
                setTimeout(() => { this.isDragging = false; }, 100); 
            }

            async checkWebXRSupport() {
                const statusEl = document.getElementById('status-text');
                const startButton = document.getElementById('btn-start');
                
                if (!navigator.xr) {
                    statusEl.innerText = 'WebXR tidak tersedia';
                    return;
                }
                
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (supported) {
                        statusEl.innerHTML = 'WebXR Siap.<br>Memuat aset...';
                    } else {
                        statusEl.innerText = 'AR tidak didukung';
                    }
                } catch (error) {
                    statusEl.innerText = 'Error WebXR';
                }
            }
            
            async loadModels() {
                const startButton = document.getElementById('btn-start');
                const statusEl = document.getElementById('status-text');

                try {
                    const loader = new THREE.GLTFLoader();

                    try {
                        const reticleGltf = await this.loadGLTF(loader, 'https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf');
                        this.reticle = reticleGltf.scene;
                    } catch (reticleError) {
                        const ringGeometry = new THREE.RingGeometry(0.3, 0.4, 32);
                        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x007bff, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                        this.reticle = new THREE.Mesh(ringGeometry, ringMaterial);
                    }
                    this.reticle.visible = false;

                    await this.loadSpecificModel(loader, this.availableModels[0].url);
                    
                    statusEl.innerText = 'Siap untuk AR';
                    startButton.disabled = false;

                } catch (error) {
                    console.error(error);
                    statusEl.innerText = 'Gagal memuat model';
                }
            }

            async loadSpecificModel(loader, modelUrl) {
                try {
                    const objectGltf = await this.loadGLTF(loader, modelUrl);
                    this.arObject = objectGltf.scene;
                    
                    this.arObject.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            if (child.material && child.material.map) {
                                child.material.map.encoding = THREE.sRGBEncoding;
                            }
                        }
                    });

                    if(this.selectedObject) this.deselectObject();
                } catch (error) {
                    throw error;
                }
            }
            
            loadGLTF(loader, url) {
                return new Promise((resolve, reject) => {
                    loader.load(url, resolve, undefined, reject);
                });
            }
            
            async startAR() {
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('ar-root').style.display = 'block';

                try {
                    this.canvas = document.createElement("canvas");
                    document.body.appendChild(this.canvas);
                    this.gl = this.canvas.getContext("webgl", { xrCompatible: true, alpha: true, antialias: true });
                    
                    this.scene = new THREE.Scene();
                    
                    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
                    dirLight.position.set(10, 15, 10);
                    this.scene.add(dirLight);
                    
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                    this.scene.add(ambientLight);
                    
                    this.scene.add(this.reticle);
                    this.scene.add(this.highlightBox);
                    
                    this.renderer = new THREE.WebGLRenderer({
                        alpha: true,
                        preserveDrawingBuffer: true,
                        canvas: this.canvas,
                        context: this.gl,
                        antialias: true
                    });
                    this.renderer.autoClear = false;
                    this.renderer.outputEncoding = THREE.sRGBEncoding;
                    
                    this.camera = new THREE.PerspectiveCamera();
                    this.camera.matrixAutoUpdate = false;
                    
                    // IMPORTANT: Use #ar-root as the DOM Overlay Root
                    this.session = await navigator.xr.requestSession("immersive-ar", {
                        requiredFeatures: ['hit-test'],
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.getElementById('ar-root') }
                    });
                    
                    this.session.updateRenderState({ baseLayer: new XRWebGLLayer(this.session, this.gl) });
                    
                    this.referenceSpace = await this.session.requestReferenceSpace('local');
                    this.viewerSpace = await this.session.requestReferenceSpace('viewer');
                    
                    this.hitTestSource = await this.session.requestHitTestSource({ space: this.viewerSpace });
                    
                    this.session.addEventListener('end', () => this.onSessionEnded());
                    this.session.addEventListener('select', (event) => this.onSelect(event));
                    
                    this.session.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
                    
                    document.getElementById('standard-ui').style.pointerEvents = 'auto'; // Make Standard UI interactive when AR starts
                    this.showToast('Pindai area lantai...');
                    
                } catch (error) {
                    alert('Gagal memulai AR: ' + error.message);
                    this.exitAR();
                }
            }
            
            onXRFrame(time, frame) {
                this.session.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
                
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.session.renderState.baseLayer.framebuffer);
                
                const pose = frame.getViewerPose(this.referenceSpace);
                
                if (pose) {
                    this.renderer.clear();
                    
                    if (!this.fpvMode) {
                        this.handleHitTest(frame);
                    } else {
                        // Crucial: Update matrixWorld for accurate collision checks against fpvObject
                        // This ensures its bounding box and mesh positions are correct for raycasting.
                        this.fpvObject.updateMatrixWorld(true); 
                        this.handleFPVMovement(pose);
                    }
                    
                    for (const view of pose.views) {
                        const viewport = this.session.renderState.baseLayer.getViewport(view);
                        this.renderer.setSize(viewport.width, viewport.height);
                        this.camera.matrix.fromArray(view.transform.matrix);
                        this.camera.projectionMatrix.fromArray(view.projectionMatrix);
                        this.camera.updateMatrixWorld(true);
                        this.renderer.render(this.scene, this.camera);
                    }
                }
            }

            handleFPVMovement(pose) {
                if (!this.fpvObject) return;

                const moveSpeed = this.baseMovementSpeed * this.movementSpeedMultiplier;
                
                // 1. Ambil Matrix Kamera (Posisi & Rotasi HP saat ini)
                const view = pose.views[0];
                const cameraMatrix = new THREE.Matrix4().fromArray(view.transform.matrix);
                
                // 2. Ekstrak arah "Depan" dan "Kanan" relatif terhadap HP
                // (0, 0, -1) adalah depan kamera standar
                // (1, 0, 0) adalah kanan kamera standar
                const forward = new THREE.Vector3(0, 0, -1).applyMatrix4(cameraMatrix);
                const right = new THREE.Vector3(1, 0, 0).applyMatrix4(cameraMatrix);
                
                // PENTING: Kita ingin gerakan relatif terhadap rotasi kamera, 
                // tapi TIDAK mau posisi kamera (translation) mempengaruhi vektor arah.
                // Jadi kita kurangi dengan posisi kamera itu sendiri.
                const cameraPosition = new THREE.Vector3().setFromMatrixPosition(cameraMatrix);
                forward.sub(cameraPosition);
                right.sub(cameraPosition);

                // 3. FLATTEN ke Lantai (Abaikan Y)
                // Agar saat nunduk/dongak, gerakan tetap mendatar di lantai
                forward.y = 0;
                right.y = 0;
                
                // Normalisasi (panjang vektor jadi 1) agar kecepatan konsisten
                forward.normalize();
                right.normalize();

                const desiredMovement = new THREE.Vector3();
                
                // 4. Mapping Joystick
                // LOGIKA AR: Kita menggerakkan DUNIA, bukan KAMERA.
                // Jika Joystick MAJU (Z positif di nipplejs kadang Y), kita ingin user merasa maju.
                // User Maju = Objek Mundur (Mendekat ke user).
                
                // Joystick Y (Maju/Mundur)
                if (this.moveVec.z !== 0) {
                    // moveVec.z positif (atas) -> User Maju -> Objek Mundur (arah lawanan forward)
                    // moveVec.z negatif (bawah) -> User Mundur -> Objek Maju (arah forward)
                    const speedZ = this.moveVec.z * moveSpeed;
                    // Kita tarik objek berlawanan arah pandangan
                    desiredMovement.add(forward.multiplyScalar(-speedZ));
                }
                
                // Joystick X (Kiri/Kanan)
                if (this.moveVec.x !== 0) {
                    const speedX = this.moveVec.x * moveSpeed;
                    // Joystick Kanan -> User Geser Kanan -> Objek Geser Kiri (arah lawanan right)
                    desiredMovement.add(right.multiplyScalar(-speedX));
                }

                // 5. Kontrol Elevator (Naik/Turun Vertikal)
                if (this.verticalSpeed !== 0) {
                    // Tombol Naik -> User Naik -> Objek Turun
                    desiredMovement.y -= this.verticalSpeed;
                }

                // 6. Cek Tabrakan
                const adjustedMovement = this.checkFPVCollisions(desiredMovement);
                
                // 7. Terapkan Gerakan
                this.fpvObject.position.add(adjustedMovement);
            }
            
            handleHitTest(frame) {
                if (!this.hitTestSource || !this.reticle) return;
                const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                if (hitTestResults.length > 0) {
                    const hitPose = hitTestResults[0].getPose(this.referenceSpace);
                    if (hitPose) {
                        this.reticle.visible = true;
                        this.reticle.position.copy(hitPose.transform.position);
                        this.reticle.updateMatrixWorld(true);
                    }
                } else {
                    this.reticle.visible = false;
                }
            }
            
            onSelect(event) {
                if (this.isUIInteraction || this.isDragging || this.fpvMode) return;

                const frame = event.frame;
                const inputSource = event.inputSource;
                
                if (inputSource && frame && inputSource.targetRaySpace) {
                    const pose = frame.getPose(inputSource.targetRaySpace, this.referenceSpace);
                    if (pose) {
                        const origin = new THREE.Vector3(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
                        const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion(
                            pose.transform.orientation.x, pose.transform.orientation.y, pose.transform.orientation.z, pose.transform.orientation.w
                        ));
                        
                        this.raycaster.set(origin, direction);
                        const intersects = this.raycaster.intersectObjects(this.placedObjects, true);
                        
                        if (intersects.length > 0) {
                            let selectedObj = intersects[0].object;
                            while (selectedObj.parent && !this.placedObjects.includes(selectedObj)) {
                                selectedObj = selectedObj.parent;
                            }
                            if (this.placedObjects.includes(selectedObj)) {
                                this.selectObject(selectedObj);
                                return;
                            }
                        }
                    }
                }
                
                if (this.reticle.visible && this.arObject && !this.selectedObject) {
                    this.placeObject();
                } else if (this.selectedObject) {
                    this.deselectObject();
                }
            }

            placeObject() {
                if (!this.arObject) return;

                // 1. Clone Model Asli
                const rawModel = this.arObject.clone();
                
                // 2. Hitung Bounding Box untuk cari titik tengah visual
                const box = new THREE.Box3().setFromObject(rawModel);
                const center = new THREE.Vector3();
                box.getCenter(center);
                
                // 3. Buat Wadah (Group) sebagai Pivot Point baru
                const pivotGroup = new THREE.Group();
                
                // 4. Masukkan model ke wadah, dan geser supaya tengahnya pas di (0,0,0) wadah
                // - center.x/z: Geser tengah ke 0
                // - box.min.y: Geser dasar objek ke 0 (supaya napak lantai)
                rawModel.position.x = -center.x;
                rawModel.position.y = -box.min.y;
                rawModel.position.z = -center.z;
                
                pivotGroup.add(rawModel);

                // 5. Tempatkan Wadah di posisi Reticle
                pivotGroup.position.copy(this.reticle.position);
                pivotGroup.rotation.y = 0;
                pivotGroup.scale.set(1, 1, 1);
                
                // ID untuk keperluan tracking/hapus
                pivotGroup.userData.objectId = this.objectIndex++;
                
                this.scene.add(pivotGroup);
                this.placedObjects.push(pivotGroup);
                this.selectObject(pivotGroup);
            }

            selectObject(object) {
                this.selectedObject = object;
                this.updateHighlightBox();
                document.getElementById('action-bar').style.display = 'flex';
                document.getElementById('idle-menu').style.display = 'none';
                this.showToast("1 Jari: Putar | 2 Jari: Cubit");
            }

            updateHighlightBox() {
                if (!this.selectedObject || !this.highlightBox) return;
                const box = new THREE.Box3().setFromObject(this.selectedObject);
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                box.getSize(size);
                box.getCenter(center);
                this.highlightBox.scale.copy(size);
                this.highlightBox.position.copy(center);
                this.highlightBox.visible = true;
            }

            deselectObject() {
                this.selectedObject = null;
                this.highlightBox.visible = false;
                document.getElementById('action-bar').style.display = 'none';
                document.getElementById('idle-menu').style.display = 'flex';
                this.showToast("Ketuk lantai untuk menempatkan");
            }

            deleteSelectedObject() {
                if (!this.selectedObject) return;
                this.scene.remove(this.selectedObject);
                const index = this.placedObjects.indexOf(this.selectedObject);
                if (index > -1) this.placedObjects.splice(index, 1);
                this.deselectObject();
                this.showToast("Objek dihapus");
            }

            enterFPVMode() {
                if (!this.selectedObject) return;

                this.fpvMode = true;
                this.fpvObject = this.selectedObject;

                this.fpvOriginalScale.copy(this.fpvObject.scale);
                this.fpvOriginalPosition.copy(this.fpvObject.position);
                this.fpvOriginalRotation.copy(this.fpvObject.rotation);

                const targetScale = this.fpvOriginalScale.x * this.fpvTargetScale;
                this.fpvObject.scale.set(targetScale, targetScale, targetScale);
                this.fpvObject.updateMatrixWorld(true); // Crucial: Update matrixWorld after scaling

                // Calculate bounding box AFTER scaling for accurate entry position
                // UPDATE: Objek sudah dinormalisasi (Dasar objek = 0,0,0 group).
                // Kita cukup posisikan group supaya dasar lantai ada di -playerHeight relatif viewer.
                
                this.fpvObject.position.set(0, -this.playerHeight, 0);
                
                // Update matrix agar collision detection akurat
                this.fpvObject.updateMatrixWorld(true);

                this.reticle.visible = false;
                this.highlightBox.visible = false;
                
                // UI Switching: Hiding Standard, Showing FPV
                document.getElementById('standard-ui').style.display = 'none';
                document.getElementById('standard-ui').style.pointerEvents = 'none';

                document.getElementById('fpv-ui').style.display = 'block';
                document.getElementById('fpv-ui').style.pointerEvents = 'auto';

                const zone = document.getElementById('joystick-zone');
                if (this.joystick) this.joystick.destroy(); 
                
                this.joystick = nipplejs.create({
                    zone: zone,
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'white'
                });

                this.joystick.on('move', (evt, data) => {
                    if (data.vector) {
                        this.moveVec.z = data.vector.y;
                        this.moveVec.x = data.vector.x;
                    }
                });

                this.joystick.on('end', () => {
                    this.moveVec = { x: 0, z: 0 };
                });
                
                this.showToast("Mode FPV Aktif");
            }

            exitFPVMode() {
                if (!this.fpvMode) return;

                this.fpvMode = false;
                if (this.fpvObject) {
                    this.fpvObject.scale.copy(this.fpvOriginalScale);
                    this.fpvObject.position.copy(this.fpvOriginalPosition);
                    this.fpvObject.rotation.copy(this.fpvOriginalRotation);
                }

                this.moveVec = { x: 0, z: 0 };
                this.verticalSpeed = 0;
                this.fpvObject = null;

                if (this.joystick) {
                    this.joystick.destroy();
                    this.joystick = null;
                }

                document.getElementById('standard-ui').style.display = 'flex';
                document.getElementById('standard-ui').style.pointerEvents = 'auto';

                document.getElementById('fpv-ui').style.display = 'none';
                document.getElementById('fpv-ui').style.pointerEvents = 'none';
                
                this.showToast("Keluar dari FPV");
            }
            
            checkFPVCollisions(movementVector) {
                const finalMovement = movementVector.clone();
                if (!this.fpvObject || finalMovement.lengthSq() === 0) return finalMovement;

                const collisionObjects = [];
                // In FPV mode, we primarily collide with the FPV object itself (its internal walls)
                // Other small placed objects are ignored for collision in this scaled view.
                if (this.fpvMode) {
                    this.fpvObject.traverse(child => {
                        // Ensure only meshes contribute to collision
                        if (child.isMesh) {
                            collisionObjects.push(child);
                        }
                    });
                } else {
                    // In normal AR mode, collide with all placed objects except the one being manipulated
                    this.placedObjects.forEach(obj => {
                        obj.traverse(child => {
                            if (child.isMesh) {
                                collisionObjects.push(child);
                            }
                        });
                    });
                }

                if (collisionObjects.length === 0) return finalMovement;

                const playerPos = new THREE.Vector3(0, 0, 0); // Player is at (0,0,0) in viewer space
                let adjustedMovement = finalMovement.clone();
                const invertedMovement = finalMovement.clone().negate();

                // --- Horizontal Collision ---
                const horizontalMovementAttempt = new THREE.Vector3(invertedMovement.x, 0, invertedMovement.z);
                if (horizontalMovementAttempt.lengthSq() > 0) {
                    const horizontalDirection = horizontalMovementAttempt.clone().normalize();
                    // Casting multiple rays for better collision detection (front-left, front, front-right)
                    const rays = [
                        horizontalDirection,
                        horizontalDirection.clone().applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI / 4), // 45 degrees left
                        horizontalDirection.clone().applyAxisAngle(new THREE.Vector3(0,1,0), -Math.PI / 4) // 45 degrees right
                    ];

                    let collisionDetected = false;
                    for (const ray of rays) {
                        this.collisionRaycaster.set(playerPos, ray);
                        this.collisionRaycaster.near = 0;
                        // Far should cover player radius + movement distance
                        this.collisionRaycaster.far = this.playerRadius + horizontalMovementAttempt.length(); 

                        const intersects = this.collisionRaycaster.intersectObjects(collisionObjects, true);
                        if (intersects.length > 0) {
                            const firstHit = intersects[0];
                            if (firstHit.distance < this.playerRadius) { // Already intersecting or very close
                                collisionDetected = true;
                                break;
                            }
                            // If an obstacle is detected in the path
                            if (firstHit.distance < horizontalMovementAttempt.length() + this.playerRadius) {
                                if (firstHit.face) { // Use normal for sliding if face data is available
                                    const hitNormal = firstHit.face.normal;
                                    hitNormal.y = 0; // Ensure we only consider horizontal collision
                                    hitNormal.normalize();

                                    const slideDirection = horizontalMovementAttempt.clone().projectOnPlane(hitNormal);
                                    if (slideDirection.lengthSq() > 0) {
                                        const invertedSlide = slideDirection.negate();
                                        adjustedMovement.x = invertedSlide.x;
                                        adjustedMovement.z = invertedSlide.z;
                                    } else {
                                        adjustedMovement.x = 0;
                                        adjustedMovement.z = 0;
                                    }
                                } else {
                                    // Fallback: If no face data (e.g., from some loaders), just stop movement
                                    adjustedMovement.x = 0;
                                    adjustedMovement.z = 0;
                                }
                                collisionDetected = true;
                                break;
                            }
                        }
                    }

                    if (collisionDetected) {
                        finalMovement.x = adjustedMovement.x;
                        finalMovement.z = adjustedMovement.z;
                    }
                }

                // --- Vertical Collision ---
                const verticalMovementAttempt = invertedMovement.y;
                if (Math.abs(verticalMovementAttempt) > 0) {
                    // Rays cast from player's head and feet positions
                    const headPos = playerPos.clone().add(new THREE.Vector3(0, this.playerHeight / 2 - this.playerRadius / 2, 0));
                    const feetPos = playerPos.clone().add(new THREE.Vector3(0, -this.playerHeight / 2 + this.playerRadius / 2, 0));
                    
                    // Check ceiling collision (if moving up)
                    if (verticalMovementAttempt > 0) { 
                        this.collisionRaycaster.set(headPos, new THREE.Vector3(0, 1, 0)); // Ray points upwards
                        this.collisionRaycaster.near = 0;
                        this.collisionRaycaster.far = verticalMovementAttempt + this.playerRadius; // Check up to player radius + movement
                        const ceilHits = this.collisionRaycaster.intersectObjects(collisionObjects, true);
                        if (ceilHits.length > 0) finalMovement.y = 0; // Stop upward movement (of fpvObject)
                    }
                    // Check ground collision (if moving down)
                    else if (verticalMovementAttempt < 0) {
                        this.collisionRaycaster.set(feetPos, new THREE.Vector3(0, -1, 0)); // Ray points downwards
                        this.collisionRaycaster.near = 0;
                        this.collisionRaycaster.far = Math.abs(verticalMovementAttempt) + this.playerRadius; // Check down to player radius + movement
                        const groundHits = this.collisionRaycaster.intersectObjects(collisionObjects, true);
                        if (groundHits.length > 0) finalMovement.y = 0; // Stop downward movement (of fpvObject)
                    }
                }

                return finalMovement;
            }

            resetObjects() {
                if (this.fpvMode) this.exitFPVMode();
                this.placedObjects.forEach(o => this.scene.remove(o));
                this.placedObjects = [];
                this.deselectObject();
                this.showToast("Area dibersihkan");
            }
            
            async exitAR() {
                if (this.session) await this.session.end();
            }
            
            onSessionEnded() {
                this.cleanup();
                document.getElementById('ar-root').style.display = 'none';
                document.getElementById('start-screen').style.display = 'block';
                console.log('AR session ended');
            }
            
            cleanup() {
                if (this.hitTestSource) {
                    this.hitTestSource.cancel();
                    this.hitTestSource = null;
                }
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                    this.canvas = null;
                }
                this.session = null;
                this.gl = null;
                this.renderer = null;
                this.fpvMode = false;
                this.fpvObject = null;
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new ARObjectPlacement();
        });
    </script>
</body>
</html>