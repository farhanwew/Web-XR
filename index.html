<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>AR Object Placement - FPV Mode</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        
        #startButton {
            padding: 15px 30px;
            font-size: 18px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        #startButton:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }
        
        #startButton:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        #status {
            margin: 15px 0;
            font-size: 16px;
            line-height: 1.4;
        }
        
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,123,255,0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            z-index: 1000;
            display: none;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        #controls-main {
            display: flex;
            margin-top: 10px;
        }

        #controls-manipulation {
            display: none;
            flex-direction: column;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.3);
            width: 100%;
        }
        
        .control-button {
            padding: 12px 20px;
            font-size: 16px;
            background: rgba(255,255,255,0.9);
            color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .control-button:hover {
            background: rgba(255,255,255,1);
        }

        .control-button.delete {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        .control-button.delete:hover {
            background: rgba(220, 53, 69, 1);
        }

        .control-button.fpv {
            background: rgba(40, 167, 69, 0.9);
            color: white;
        }

        .control-button.fpv:hover {
            background: rgba(40, 167, 69, 1);
        }

        .slider-container {
            display: flex;
            align-items: center;
            margin: 5px 0;
            color: white;
            font-size: 14px;
        }

        .slider-container label {
            margin-right: 10px;
            width: 60px;
            text-align: right;
        }

        .slider-container input[type="range"] {
            width: 150px;
            -webkit-appearance: none;
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
        }

        .slider-container input[type="range"]:hover {
            opacity: 1;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        #objectInfo {
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
        }

        #manipulation-buttons {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        /* FPV Controls */
        #fpvControls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        #fpvInfo {
            background: rgba(40, 167, 69, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 14px;
            text-align: center;
        }

        #movementControls {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
        }

        #dpadContainer {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            margin-bottom: 10px;
        }

        .dpad-button {
            background: rgba(255,255,255,0.9);
            border: none;
            border-radius: 8px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            -webkit-user-select: none;
            user-select: none;
        }

        .dpad-button:active {
            background: rgba(100,200,100,0.9);
        }

        .dpad-button.empty {
            background: transparent;
            box-shadow: none;
        }

        #fpvExitButton {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1002;
            padding: 12px 20px;
            font-size: 16px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        #exitButton {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            padding: 12px 20px;
            font-size: 16px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        #exitButton:hover {
            background: rgba(220, 53, 69, 1);
        }

        #controls-main {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }

        #fpvExitButton:hover {
            background: rgba(220, 53, 69, 1);
        }

        #heightControls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .height-button {
            padding: 10px 20px;
            font-size: 14px;
            background: rgba(255,255,255,0.9);
            color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .height-button:active {
            background: rgba(100,200,100,0.9);
        }

        #speedControl {
            margin-top: 10px;
            color: white;
            font-size: 12px;
        }

        .model-selector {
            margin: 10px 0;
            color: white;
            font-size: 14px;
        }

        .model-selector select {
            padding: 8px 12px;
            font-size: 14px;
            background: rgba(255,255,255,0.9);
            color: #333;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
        }

        .model-selector select:focus {
            outline: 2px solid #007bff;
        }
        
        canvas {
            display: block;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h1>AR Object Placement - FPV Mode</h1>
            <div id="status">
                <span class="loading"></span>
                Memeriksa dukungan WebXR...
            </div>
            <button id="startButton" disabled>Memuat...</button>
        </div>
        
        <div id="instructions">
            Arahkan kamera ke permukaan datar, lalu ketuk layar untuk menempatkan objek.<br>
            Ketuk objek untuk memilih dan memanipulasi.
        </div>

        <button id="exitButton" style="display: none;">Keluar AR</button>

        <div id="controls">
            <div id="controls-main">
                <div class="model-selector">
                    <label for="modelSelect">Pilih Model:</label>
                    <select id="modelSelect">
                        <option value="tower_house_design.glb">Tower House</option>
                        <option value="model2.glb">Model 2</option>
                        <option value="model3.glb">Model 3</option>
                    </select>
                </div>
                <button class="control-button" id="resetButton">Reset Semua</button>
            </div>
            <div id="controls-manipulation">
                <div id="objectInfo">Objek dipilih: <span id="selectedObjectId">-</span></div>
                <div class="slider-container">
                    <label for="scaleSlider">Skala:</label>
                    <input type="range" id="scaleSlider" min="0.1" max="5" value="1" step="0.1">
                </div>
                <div class="slider-container">
                    <label for="rotateSlider">Rotasi Y:</label>
                    <input type="range" id="rotateSlider" min="0" max="360" value="0" step="5">
                </div>
                <div id="manipulation-buttons">
                    <button class="control-button fpv" id="fpvButton">üö∂ Mode FPV</button>
                    <button class="control-button delete" id="deleteButton">Hapus Objek</button>
                    <button class="control-button" id="deselectButton">Batal Pilih</button>
                </div>
            </div>
        </div>

        <!-- FPV Controls -->
        <div id="fpvControls">
            <button id="fpvExitButton">Keluar Mode FPV</button>
            <div id="fpvInfo">
                Mode First-Person View üè†<br>
                <small>Jelajahi model dalam skala 1:1</small>
            </div>
            <div id="movementControls">
                <div id="dpadContainer">
                    <div class="dpad-button empty"></div>
                    <div class="dpad-button" id="forwardButton">‚ñ≤</div>
                    <div class="dpad-button empty"></div>
                    <div class="dpad-button" id="leftButton">‚óÄ</div>
                    <div class="dpad-button empty"></div>
                    <div class="dpad-button" id="rightButton">‚ñ∂</div>
                    <div class="dpad-button empty"></div>
                    <div class="dpad-button" id="backwardButton">‚ñº</div>
                    <div class="dpad-button empty"></div>
                </div>
                <div id="heightControls">
                    <button class="height-button" id="moveUpButton">Naik ‚¨Ü</button>
                    <button class="height-button" id="moveDownButton">Turun ‚¨á</button>
                </div>
                <div id="speedControl">
                    <label for="speedSlider">Kecepatan: </label>
                    <input type="range" id="speedSlider" min="0.5" max="3" value="1" step="0.5">
                    <span id="speedValue">1x</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        class ARObjectPlacement {
            constructor() {
                this.canvas = null;
                this.gl = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.session = null;
                this.referenceSpace = null;
                this.viewerSpace = null;
                this.hitTestSource = null;

                this.reticle = null;
                this.arObject = null;
                this.availableModels = [];
                this.currentModelIndex = 0;
                this.placedObjects = [];
                this.selectedObject = null;
                this.objectIndex = 0;
                this.isInteractingWithUI = false;
                this.lastUIInteraction = 0;
                
                // For object selection
                this.raycaster = new THREE.Raycaster();
                this.highlightBox = null;

                // FPV Mode
                this.fpvMode = false;
                this.fpvObject = null;
                this.fpvOriginalScale = new THREE.Vector3();
                this.fpvOriginalPosition = new THREE.Vector3();
                this.fpvOriginalRotation = new THREE.Euler();
                this.fpvTargetScale = 20; // Multiplier untuk scale 1:1
                this.baseMovementSpeed = 0.1; // Base speed dalam meter
                this.movementSpeedMultiplier = 1;
                
                // FPV Collision Detection Properties
                this.playerHeight = 1.7; // Approx user height in meters
                this.playerRadius = 0.3; // Approx user radius
                this.collisionRaycaster = new THREE.Raycaster(); // Dedicated raycaster for FPV collisions

                // Movement state
                this.movementState = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    up: false,
                    down: false
                };
                
                this.init();
            }
            
            async init() {
                await this.checkWebXRSupport();
                this.setupEventListeners();
                await this.loadModels();
                this.createSelectionHighlight();
            }

            createSelectionHighlight() {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const edges = new THREE.EdgesGeometry(geometry);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00, 
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.8
                });
                this.highlightBox = new THREE.LineSegments(edges, material);
                this.highlightBox.visible = false;
            }
            
            async checkWebXRSupport() {
                const statusEl = document.getElementById('status');
                const startButton = document.getElementById('startButton');
                
                if (!navigator.xr) {
                    statusEl.innerHTML = 'WebXR tidak tersedia di browser ini';
                    startButton.textContent = 'WebXR Tidak Tersedia';
                    return;
                }
                
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (supported) {
                        statusEl.innerHTML = 'WebXR AR didukung! Memuat model...';
                        startButton.disabled = false;
                    } else {
                        statusEl.innerHTML = 'WebXR AR tidak didukung di perangkat ini';
                        startButton.textContent = 'AR Tidak Didukung';
                    }
                } catch (error) {
                    console.error('Error checking WebXR support:', error);
                    statusEl.innerHTML = 'Error memeriksa dukungan WebXR';
                    startButton.textContent = 'Error';
                }
            }
            
            async loadModels() {
                const statusEl = document.getElementById('status');
                const startButton = document.getElementById('startButton');

                try {
                    const loader = new THREE.GLTFLoader();

                    const reticleGltf = await this.loadGLTF(loader, 'https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf');
                    this.reticle = reticleGltf.scene;
                    this.reticle.visible = false;

                    // Define available models
                    this.availableModels = [
                        { name: 'Tower House', url: 'tower_house_design.glb' },
                        { name: 'Modern House', url: 'modern_house.glb' },
                        { name: 'Building Model', url: 'building_model.glb' }
                    ];

                    // Load the first model
                    await this.loadSpecificModel(loader, this.availableModels[0].url);
                    
                    this.arObject.traverse((child) => {
                        if (child.isMesh) {
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.needsUpdate = true;
                                        if (mat.map) {
                                            mat.map.encoding = THREE.sRGBEncoding;
                                        }
                                    });
                                } else {
                                    child.material.needsUpdate = true;
                                    if (child.material.map) {
                                        child.material.map.encoding = THREE.sRGBEncoding;
                                    }
                                }
                            }

                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    statusEl.innerHTML = 'Model berhasil dimuat! Siap memulai AR';
                    startButton.textContent = 'Mulai AR';
                    startButton.disabled = false;

                    console.log('Models loaded successfully');

                } catch (error) {
                    console.error('Error loading models:', error);
                    statusEl.innerHTML = 'Gagal memuat model: ' + error.message;
                    startButton.textContent = 'Error Memuat Model';
                }
            }

            async loadSpecificModel(loader, modelUrl) {
                try {
                    const objectGltf = await this.loadGLTF(loader, modelUrl);
                    this.arObject = objectGltf.scene;

                    // Clear previous placed objects that used the old model
                    this.placedObjects.forEach(obj => {
                        this.scene.remove(obj);
                    });
                    this.placedObjects = [];
                    this.deselectObject();

                } catch (error) {
                    console.error(`Error loading model ${modelUrl}:`, error);
                    throw error;
                }
            }
            
            loadGLTF(loader, url) {
                return new Promise((resolve, reject) => {
                    loader.load(url, resolve, undefined, reject);
                });
            }
            
            setupEventListeners() {
                const startButton = document.getElementById('startButton');
                const resetButton = document.getElementById('resetButton');
                const exitButton = document.getElementById('exitButton');
                const deleteButton = document.getElementById('deleteButton');
                const deselectButton = document.getElementById('deselectButton');
                const fpvButton = document.getElementById('fpvButton');
                const scaleSlider = document.getElementById('scaleSlider');
                const rotateSlider = document.getElementById('rotateSlider');
                const modelSelect = document.getElementById('modelSelect');
                const controlsContainer = document.getElementById('controls');

                startButton.addEventListener('click', () => this.startAR());

                // Model selector event
                modelSelect.addEventListener('change', (e) => {
                    const selectedModel = this.availableModels.find(model => model.url === e.target.value);
                    if (selectedModel && this.arObject) {
                        this.loadSpecificModel(new THREE.GLTFLoader(), selectedModel.url)
                            .then(() => {
                                console.log(`Switched to model: ${selectedModel.name}`);
                            })
                            .catch(error => {
                                console.error('Failed to load selected model:', error);
                                alert('Gagal memuat model yang dipilih');
                            });
                    }
                });
                
                // Controls container events
                controlsContainer.addEventListener('touchstart', (e) => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                    e.stopPropagation();
                });
                controlsContainer.addEventListener('touchend', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                controlsContainer.addEventListener('click', (e) => {
                    this.lastUIInteraction = Date.now();
                    e.stopPropagation();
                });
                
                // Button events
                resetButton.addEventListener('click', () => {
                    this.resetObjects();
                    this.lastUIInteraction = Date.now();
                });
                
                exitButton.addEventListener('click', () => {
                    this.exitAR();
                    this.lastUIInteraction = Date.now();
                });

                deleteButton.addEventListener('click', () => {
                    this.deleteSelectedObject();
                    this.lastUIInteraction = Date.now();
                });

                deselectButton.addEventListener('click', () => {
                    this.deselectObject();
                    this.lastUIInteraction = Date.now();
                });

                fpvButton.addEventListener('click', () => {
                    this.enterFPVMode();
                    this.lastUIInteraction = Date.now();
                });

                // Slider events
                this.setupSliderEvents(scaleSlider, 'scale');
                this.setupSliderEvents(rotateSlider, 'rotate');

                // FPV Controls
                this.setupFPVControls();
            }

            setupSliderEvents(slider, type) {
                slider.addEventListener('touchstart', () => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                });
                slider.addEventListener('touchend', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                slider.addEventListener('mousedown', () => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                });
                slider.addEventListener('mouseup', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                
                if (type === 'scale') {
                    slider.addEventListener('input', (e) => this.onScaleChange(e.target.value));
                } else if (type === 'rotate') {
                    slider.addEventListener('input', (e) => this.onRotateChange(e.target.value));
                }
            }

            setupFPVControls() {
                const fpvControlsContainer = document.getElementById('fpvControls');
                const fpvExitButton = document.getElementById('fpvExitButton');
                const speedSlider = document.getElementById('speedSlider');
                
                // Prevent touch events from propagating
                fpvControlsContainer.addEventListener('touchstart', (e) => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                    e.stopPropagation();
                });
                fpvControlsContainer.addEventListener('touchend', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });

                // Movement buttons
                this.setupMovementButton('forwardButton', 'forward');
                this.setupMovementButton('backwardButton', 'backward');
                this.setupMovementButton('leftButton', 'left');
                this.setupMovementButton('rightButton', 'right');
                this.setupMovementButton('moveUpButton', 'up');
                this.setupMovementButton('moveDownButton', 'down');

                // Speed control
                speedSlider.addEventListener('input', (e) => {
                    this.movementSpeedMultiplier = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = this.movementSpeedMultiplier + 'x';
                });

                // Exit FPV
                fpvExitButton.addEventListener('click', () => {
                    this.exitFPVMode();
                    this.lastUIInteraction = Date.now();
                });
            }

            setupMovementButton(buttonId, direction) {
                const button = document.getElementById(buttonId);
                
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.movementState[direction] = true;
                    this.lastUIInteraction = Date.now();
                });
                
                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.movementState[direction] = false;
                    this.lastUIInteraction = Date.now();
                });

                button.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.movementState[direction] = true;
                    this.lastUIInteraction = Date.now();
                });
                
                button.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.movementState[direction] = false;
                    this.lastUIInteraction = Date.now();
                });

                button.addEventListener('mouseleave', () => {
                    this.movementState[direction] = false;
                });
            }
            
            async startAR() {
                try {
                    this.canvas = document.createElement("canvas");
                    document.body.appendChild(this.canvas);
                    this.gl = this.canvas.getContext("webgl", {
                        xrCompatible: true,
                        alpha: true,
                        antialias: true
                    });
                    
                    if (!this.gl) {
                        throw new Error("WebGL not supported");
                    }
                    
                    this.scene = new THREE.Scene();
                    
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                    directionalLight.position.set(10, 15, 10);
                    this.scene.add(directionalLight);
                    
                    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                    directionalLight2.position.set(-10, 10, -10);
                    this.scene.add(directionalLight2);
                    
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                    this.scene.add(ambientLight);
                    
                    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                    hemiLight.position.set(0, 20, 0);
                    this.scene.add(hemiLight);
                    
                    this.scene.add(this.reticle);
                    this.scene.add(this.highlightBox);
                    
                    this.renderer = new THREE.WebGLRenderer({
                        alpha: true,
                        preserveDrawingBuffer: true,
                        canvas: this.canvas,
                        context: this.gl,
                        antialias: true
                    });
                    this.renderer.autoClear = false;
                    this.renderer.outputEncoding = THREE.sRGBEncoding;
                    this.renderer.physicallyCorrectLights = true;
                    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    this.renderer.toneMappingExposure = 1.0;
                    
                    this.camera = new THREE.PerspectiveCamera();
                    this.camera.matrixAutoUpdate = false;
                    
                    this.session = await navigator.xr.requestSession("immersive-ar", {
                        requiredFeatures: ['hit-test'],
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.getElementById('container') }
                    });
                    
                    this.session.updateRenderState({
                        baseLayer: new XRWebGLLayer(this.session, this.gl)
                    });
                    
                    this.referenceSpace = await this.session.requestReferenceSpace('local');
                    this.viewerSpace = await this.session.requestReferenceSpace('viewer');
                    
                    this.hitTestSource = await this.session.requestHitTestSource({ 
                        space: this.viewerSpace 
                    });
                    
                    this.session.addEventListener('end', () => this.onSessionEnded());
                    this.session.addEventListener('select', (event) => this.onSelect(event));
                    
                    this.session.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
                    
                    document.getElementById('ui').style.display = 'none';
                    document.getElementById('instructions').style.display = 'block';
                    document.getElementById('controls').style.display = 'flex';
                    document.getElementById('exitButton').style.display = 'block';
                    
                    console.log('AR session started successfully');
                    
                } catch (error) {
                    console.error('Error starting AR:', error);
                    alert('Gagal memulai AR: ' + error.message);
                    this.cleanup();
                }
            }
            
            onXRFrame(time, frame) {
                this.session.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
                
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.session.renderState.baseLayer.framebuffer);
                
                const pose = frame.getViewerPose(this.referenceSpace);
                
                if (pose) {
                    this.renderer.clear();
                    
                    if (!this.fpvMode) {
                        this.handleHitTest(frame);
                    } else {
                        this.handleFPVMovement(pose);
                    }
                    
                    for (const view of pose.views) {
                        const viewport = this.session.renderState.baseLayer.getViewport(view);
                        this.renderer.setSize(viewport.width, viewport.height);
                        
                        // Always use XR camera matrix
                        this.camera.matrix.fromArray(view.transform.matrix);
                        this.camera.projectionMatrix.fromArray(view.projectionMatrix);
                        this.camera.updateMatrixWorld(true);
                        
                        this.renderer.render(this.scene, this.camera);
                    }
                }
            }

            handleFPVMovement(pose) {
                if (!this.fpvObject) return;

                const moveSpeed = this.baseMovementSpeed * this.movementSpeedMultiplier;
                
                // Get camera's current position and orientation
                const view = pose.views[0];
                const cameraMatrix = new THREE.Matrix4().fromArray(view.transform.matrix);
                
                // Extract forward and right vectors from camera
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                
                forward.applyMatrix4(cameraMatrix);
                right.applyMatrix4(cameraMatrix);
                
                // Project to horizontal plane (remove Y component)
                forward.y = 0;
                forward.normalize();
                right.y = 0;
                right.normalize();

                // Calculate desired movement offset
                const desiredMovement = new THREE.Vector3();
                
                // INVERSE movement: when user "moves forward", world moves backward
                if (this.movementState.forward) {
                    desiredMovement.sub(forward.multiplyScalar(moveSpeed));
                }
                if (this.movementState.backward) {
                    desiredMovement.add(forward.multiplyScalar(moveSpeed));
                }
                if (this.movementState.left) {
                    desiredMovement.add(right.multiplyScalar(moveSpeed));
                }
                if (this.movementState.right) {
                    desiredMovement.sub(right.multiplyScalar(moveSpeed));
                }
                if (this.movementState.up) {
                    desiredMovement.y -= moveSpeed; // Move world down = user goes up
                }
                if (this.movementState.down) {
                    desiredMovement.y += moveSpeed; // Move world up = user goes down
                }

                // --- INTEGRATE COLLISION CHECK HERE ---
                const adjustedMovement = this.checkFPVCollisions(desiredMovement);

                // Apply adjusted movement to the FPV object
                this.fpvObject.position.add(adjustedMovement);

                // Debug log
                if (adjustedMovement.length() > 0) { // Log only if actual movement occurred
                    console.log('Moving object:', adjustedMovement, 'New position:', this.fpvObject.position);
                }
            }
            
            handleHitTest(frame) {
                if (!this.hitTestSource || !this.reticle) return;
                
                const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                
                if (hitTestResults.length > 0) {
                    const hitPose = hitTestResults[0].getPose(this.referenceSpace);
                    
                    this.reticle.visible = true;
                    this.reticle.position.set(
                        hitPose.transform.position.x,
                        hitPose.transform.position.y,
                        hitPose.transform.position.z
                    );
                    this.reticle.updateMatrixWorld(true);
                } else {
                    this.reticle.visible = false;
                }
            }
            
            onSelect(event) {
                const timeSinceLastUI = Date.now() - this.lastUIInteraction;
                
                if (this.isInteractingWithUI || timeSinceLastUI < 500) {
                    console.log('Ignoring select: UI interaction in progress or too recent');
                    return;
                }

                if (this.fpvMode) {
                    return;
                }

                const frame = event.frame;
                const inputSource = event.inputSource;
                
                if (inputSource && frame) {
                    const pose = frame.getPose(inputSource.targetRaySpace, this.referenceSpace);
                    
                    if (pose) {
                        const origin = new THREE.Vector3(
                            pose.transform.position.x,
                            pose.transform.position.y,
                            pose.transform.position.z
                        );
                        
                        const direction = new THREE.Vector3(0, 0, -1);
                        direction.applyQuaternion(new THREE.Quaternion(
                            pose.transform.orientation.x,
                            pose.transform.orientation.y,
                            pose.transform.orientation.z,
                            pose.transform.orientation.w
                        ));
                        
                        this.raycaster.set(origin, direction);
                        
                        const intersects = this.raycaster.intersectObjects(this.placedObjects, true);
                        
                        if (intersects.length > 0) {
                            let selectedObj = intersects[0].object;
                            while (selectedObj.parent && !this.placedObjects.includes(selectedObj)) {
                                selectedObj = selectedObj.parent;
                            }
                            
                            if (this.placedObjects.includes(selectedObj)) {
                                this.selectObject(selectedObj);
                                console.log('Object selected via raycast');
                                return;
                            }
                        }
                    }
                }
                
                if (this.reticle.visible && this.arObject) {
                    this.placeObject();
                }
            }

            placeObject() {
                const clone = this.arObject.clone();
                clone.position.copy(this.reticle.position);
                clone.rotation.y = 0;
                clone.scale.set(1, 1, 1);
                
                clone.userData.objectId = this.objectIndex++;
                
                this.scene.add(clone);
                this.placedObjects.push(clone);
                
                this.selectObject(clone);
                
                console.log('Object placed. Total objects:', this.placedObjects.length);
            }

            selectObject(object) {
                this.selectedObject = object;
                
                this.updateHighlightBox();
                
                const manipulationControls = document.getElementById('controls-manipulation');
                manipulationControls.style.display = 'flex';

                document.getElementById('selectedObjectId').textContent = '#' + this.selectedObject.userData.objectId;
                document.getElementById('scaleSlider').value = this.selectedObject.scale.x;
                document.getElementById('rotateSlider').value = (this.selectedObject.rotation.y * 180 / Math.PI) % 360;
                
                console.log('Object selected:', this.selectedObject.userData.objectId);
            }

            updateHighlightBox() {
                if (!this.selectedObject || !this.highlightBox) return;

                const box = new THREE.Box3().setFromObject(this.selectedObject);
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                
                box.getSize(size);
                box.getCenter(center);

                this.highlightBox.scale.copy(size);
                this.highlightBox.position.copy(center);
                this.highlightBox.visible = true;
            }

            deselectObject() {
                this.selectedObject = null;
                this.highlightBox.visible = false;
                
                const manipulationControls = document.getElementById('controls-manipulation');
                manipulationControls.style.display = 'none';
                
                console.log('Object deselected');
            }

            deleteSelectedObject() {
                if (!this.selectedObject) {
                    console.log('No object selected to delete');
                    return;
                }

                const objectId = this.selectedObject.userData.objectId;
                
                this.scene.remove(this.selectedObject);
                
                const index = this.placedObjects.indexOf(this.selectedObject);
                if (index > -1) {
                    this.placedObjects.splice(index, 1);
                }
                
                console.log('Object deleted:', objectId, 'Remaining objects:', this.placedObjects.length);
                
                this.deselectObject();
            }

            enterFPVMode() {
                if (!this.selectedObject) {
                    console.log('No object selected for FPV mode');
                    return;
                }

                console.log('Entering FPV mode');
                this.fpvMode = true;
                this.fpvObject = this.selectedObject;

                // Save original state
                this.fpvOriginalScale.copy(this.fpvObject.scale);
                this.fpvOriginalPosition.copy(this.fpvObject.position);
                this.fpvOriginalRotation.copy(this.fpvObject.rotation);

                // Scale up to approximate 1:1
                const targetScale = this.fpvOriginalScale.x * this.fpvTargetScale;
                this.fpvObject.scale.set(targetScale, targetScale, targetScale);

                // Hide AR UI and show FPV controls
                this.reticle.visible = false;
                this.highlightBox.visible = false;
                document.getElementById('controls').style.display = 'none';
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('fpvControls').style.display = 'flex';

                console.log('FPV mode activated. Scale:', targetScale, 'Position:', this.fpvObject.position);
            }

            exitFPVMode() {
                if (!this.fpvMode) return;

                console.log('Exiting FPV mode');
                this.fpvMode = false;

                // Restore original state
                if (this.fpvObject) {
                    this.fpvObject.scale.copy(this.fpvOriginalScale);
                    this.fpvObject.position.copy(this.fpvOriginalPosition);
                    this.fpvObject.rotation.copy(this.fpvOriginalRotation);
                }

                // Reset movement state
                Object.keys(this.movementState).forEach(key => {
                    this.movementState[key] = false;
                });

                // Show AR UI and hide FPV controls
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('fpvControls').style.display = 'none';

                this.fpvObject = null;

                console.log('FPV mode deactivated');
            }
            
            checkFPVCollisions(movementVector) {
                const finalMovement = movementVector.clone();
                if (!this.fpvObject || finalMovement.lengthSq() === 0) {
                    return finalMovement;
                }

                // Get all collision objects from the scene (all placed objects except the current FPV object)
                const collisionObjects = [];
                this.placedObjects.forEach(obj => {
                    if (obj !== this.fpvObject) {
                        obj.traverse(child => {
                            if (child.isMesh) {
                                collisionObjects.push(child);
                            }
                        });
                    }
                });

                if (collisionObjects.length === 0) return finalMovement;

                // Player position (camera) at world origin
                const playerPos = new THREE.Vector3(0, 0, 0);
                const playerRadius = 0.5; // Slightly larger radius for better collision detection
                const playerHeight = 1.8; // Height for vertical collision

                let adjustedMovement = finalMovement.clone();

                // Check horizontal collisions (x, z plane)
                const horizontalMovement = new THREE.Vector3(adjustedMovement.x, 0, adjustedMovement.z);
                if (horizontalMovement.lengthSq() > 0) {
                    const horizontalDirection = horizontalMovement.clone().normalize();

                    // Cast multiple rays for better collision detection
                    const rays = [
                        horizontalDirection,
                        horizontalDirection.clone().multiplyScalar(0.8).add(new THREE.Vector3(0.3, 0, 0.3).normalize()),
                        horizontalDirection.clone().multiplyScalar(0.8).add(new THREE.Vector3(-0.3, 0, -0.3).normalize())
                    ];

                    let collisionDetected = false;

                    for (const ray of rays) {
                        this.collisionRaycaster.set(playerPos, ray);
                        this.collisionRaycaster.near = 0;
                        this.collisionRaycaster.far = playerRadius + 0.1;

                        const intersects = this.collisionRaycaster.intersectObjects(collisionObjects, true);

                        if (intersects.length > 0) {
                            collisionDetected = true;
                            const hitNormal = intersects[0].face.normal;
                            hitNormal.y = 0; // Ensure we only consider horizontal collision
                            hitNormal.normalize();

                            // Slide along the surface
                            const slideDirection = horizontalMovement.clone().projectOnPlane(hitNormal);
                            if (slideDirection.lengthSq() > 0) {
                                adjustedMovement.x = slideDirection.x;
                                adjustedMovement.z = slideDirection.z;
                            } else {
                                // If can't slide, stop movement in this direction
                                adjustedMovement.x = 0;
                                adjustedMovement.z = 0;
                            }
                            break;
                        }
                    }
                }

                // Check vertical collisions (y axis)
                if (Math.abs(adjustedMovement.y) > 0) {
                    // Check ground collision (below)
                    if (adjustedMovement.y < 0) {
                        this.collisionRaycaster.set(
                            playerPos.clone().add(new THREE.Vector3(0, -playerHeight/2, 0)),
                            new THREE.Vector3(0, -1, 0)
                        );
                        this.collisionRaycaster.near = 0;
                        this.collisionRaycaster.far = playerHeight;

                        const groundIntersects = this.collisionRaycaster.intersectObjects(collisionObjects, true);
                        if (groundIntersects.length > 0 && groundIntersects[0].distance < 0.1) {
                            adjustedMovement.y = 0; // Stop downward movement
                        }
                    }

                    // Check ceiling collision (above)
                    if (adjustedMovement.y > 0) {
                        this.collisionRaycaster.set(
                            playerPos.clone().add(new THREE.Vector3(0, playerHeight/2, 0)),
                            new THREE.Vector3(0, 1, 0)
                        );
                        this.collisionRaycaster.near = 0;
                        this.collisionRaycaster.far = 2;

                        const ceilingIntersects = this.collisionRaycaster.intersectObjects(collisionObjects, true);
                        if (ceilingIntersects.length > 0 && ceilingIntersects[0].distance < 0.1) {
                            adjustedMovement.y = 0; // Stop upward movement
                        }
                    }
                }

                // Final distance check to prevent getting too close to objects
                const testPos = playerPos.clone().add(adjustedMovement);
                this.collisionRaycaster.set(playerPos, testPos.clone().sub(playerPos).normalize());
                this.collisionRaycaster.near = 0;
                this.collisionRaycaster.far = adjustedMovement.length() + 0.1;

                const finalIntersects = this.collisionRaycaster.intersectObjects(collisionObjects, true);
                if (finalIntersects.length > 0 && finalIntersects[0].distance < playerRadius) {
                    // If collision detected, reduce movement
                    adjustedMovement.multiplyScalar(0.5);

                    // If still colliding, stop movement completely
                    const testPos2 = playerPos.clone().add(adjustedMovement);
                    this.collisionRaycaster.set(playerPos, testPos2.clone().sub(playerPos).normalize());
                    this.collisionRaycaster.near = 0;
                    this.collisionRaycaster.far = adjustedMovement.length() + 0.01;

                    const finalIntersects2 = this.collisionRaycaster.intersectObjects(collisionObjects, true);
                    if (finalIntersects2.length > 0 && finalIntersects2[0].distance < playerRadius) {
                        adjustedMovement.set(0, 0, 0);
                    }
                }

                return adjustedMovement;
            }

            onScaleChange(value) {
                if (this.selectedObject && !this.fpvMode) {
                    const scale = parseFloat(value);
                    this.selectedObject.scale.set(scale, scale, scale);
                    this.updateHighlightBox();
                }
            }

            onRotateChange(value) {
                if (this.selectedObject && !this.fpvMode) {
                    const rotationY = parseFloat(value) * Math.PI / 180;
                    this.selectedObject.rotation.y = rotationY;
                    this.updateHighlightBox();
                }
            }

            resetObjects() {
                if (this.fpvMode) {
                    this.exitFPVMode();
                }

                this.placedObjects.forEach(object => {
                    this.scene.remove(object);
                });
                this.placedObjects = [];
                this.deselectObject();
                this.objectIndex = 0;
                console.log('All objects removed');
            }
            
            async exitAR() {
                if (this.session) {
                    await this.session.end();
                }
            }
            
            onSessionEnded() {
                this.cleanup();
                
                document.getElementById('ui').style.display = 'block';
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                document.getElementById('fpvControls').style.display = 'none';
                document.getElementById('exitButton').style.display = 'none';
                
                console.log('AR session ended');
            }
            
            cleanup() {
                if (this.hitTestSource) {
                    this.hitTestSource.cancel();
                    this.hitTestSource = null;
                }
                
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                    this.canvas = null;
                }
                
                this.session = null;
                this.gl = null;
                this.renderer = null;
                this.referenceSpace = null;
                this.viewerSpace = null;
                this.fpvMode = false;
                this.fpvObject = null;
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new ARObjectPlacement();
        });
    </script>
</body>
</html>